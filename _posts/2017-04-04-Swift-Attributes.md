---
layout: post
tags: ["Swift"]
title: "Attributes in Swift"
author: Jordan Morgan
description: "Attributes can keep code clean and conscise without much effort. Today, let's cover some common, and uncommon, use cases."
image: /assets/images/logo.png
---
<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>Swift + Attributes</title><style>
      * {
        font-family: Georgia, Cambria, "Times New Roman", Times, serif;
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">Swift + Attributes</h1>
</header>
<section data-field="subtitle" class="p-summary">
Or, ‚ÄúOh, Those @ Thingys‚Äù
</section>
<section data-field="body" class="e-content">
<section name="01b1" class="section section--body section--first"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--outsetColumn"><figure name="4622" id="4622" class="graf graf--figure graf--layoutOutsetCenter graf--leading"><div class="aspectRatioPlaceholder is-locked" style="max-width: 1000px; max-height: 667px;"><div class="aspectRatioPlaceholder-fill" style="padding-bottom: 66.7%;"></div><img class="graf-image" data-image-id="1*OlfwF9y6uGvrywGgsAic_Q.jpeg" data-width="2100" data-height="1400" src="https://cdn-images-1.medium.com/max/1000/1*OlfwF9y6uGvrywGgsAic_Q.jpeg"></div><figcaption class="imageCaption">For some reason <a href="https://medium.com/the-traveled-ios-developers-guide/swift-keywords-v-3-0-1-f59783bf26c#.7a4h5wgcs" data-href="https://medium.com/the-traveled-ios-developers-guide/swift-keywords-v-3-0-1-f59783bf26c#.7a4h5wgcs" class="markup--anchor markup--figure-anchor" target="_blank">I‚Äôm still stuck on the MacBook + Paper</a>¬†combo.</figcaption></figure></div><div class="section-inner sectionLayout--insetColumn"><h3 name="640e" id="640e" class="graf graf--h3 graf-after--figure graf--title">Swift + Attributes</h3><h4 name="19cc" id="19cc" class="graf graf--h4 graf-after--h3 graf--trailing graf--subtitle">Or, ‚ÄúOh, Those @¬†Thingys‚Äù</h4></div></div></section><section name="e14f" class="section section--body"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><p name="da0d" id="da0d" class="graf graf--p graf--leading graf--trailing"><a href="https://www.buddybuild.com/blog/optimizing-your-swift-codebase-with-attributes" data-href="https://www.buddybuild.com/blog/optimizing-your-swift-codebase-with-attributes" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">This week‚Äôs post is sponsored by BuddyBuild‚Ää‚Äî‚Ääread the post over on their blog as well.</a></p></div></div></section><section name="5298" class="section section--body"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><p name="8586" id="8586" class="graf graf--p graf--hasDropCapModel graf--hasDropCap graf--leading"><span class="graf-dropCap">I</span> think we‚Äôve all been there. We‚Äôve just picked up programming, or we start learning a new language where things are foreign to us‚Ää‚Äî‚Ääand we happen across some code. We may not understand it, but we think it works. So, we just take it in good faith and continue on, none the wiser.</p><p name="76cd" id="76cd" class="graf graf--p graf-after--p">This used to be my approach when incorporating Swift‚Äôs attributes into my own work. <a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Attributes.html" data-href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Attributes.html" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">Swift supports a robust variety of attributes,</a> and when browsing Github repos‚Ää‚Äî‚Ääwe may happen across one or two we don‚Äôt recognize. If you‚Äôre like me, you might jot it down to Google and then be on our way.</p><p name="bed3" id="bed3" class="graf graf--p graf-after--p">No more! This week, we take a peek under the curtain at what attributes are, what they do and some fun ones to know about üí´. Lets.begin()</p><h4 name="351b" id="351b" class="graf graf--h4 graf-after--p">Why use Swift‚Äôs attributes?</h4><p name="e92a" id="e92a" class="graf graf--p graf-after--h4">Attributes help developers improve the efficiency of their codebase, without sacrificing the quality of their code. It makes for code that‚Äôs easier to read, ultimately easier to maintain and hopefully safer to use.</p><p name="8e06" id="8e06" class="graf graf--p graf-after--p">I like to think that efficiency is always at the forefront of my development. And really‚Ää‚Äî‚Ääthat‚Äôs what a lot of these attributes can bring to the table, some good ol‚Äô fashioned efficiency.</p><h4 name="28f6" id="28f6" class="graf graf--h4 graf-after--p">Groundwork</h4><p name="662c" id="662c" class="graf graf--p graf-after--h4">At the expense of starting by providing a boilerplate definition, let‚Äôs start by providing a boilerplate definition ü§ì.</p><p name="55b0" id="55b0" class="graf graf--p graf-after--p">I think it‚Äôs requisite to quickly hit on what exactly an attribute is. And really, all a Swift attribute is/does is provide more information about a either type or declaration. This information can dictate everything from compiler warnings to how something is handled in memory.</p><p name="92e1" id="92e1" class="graf graf--p graf-after--p">No matter the flavor, each one is preceded by an ‚Äú@‚Äù symbol. In addition, declaration attributes may also accept arguments inside of enclosing parentheses.</p><p name="8b2a" id="8b2a" class="graf graf--p graf-after--p">So, put simply:</p><pre name="7056" id="7056" class="graf graf--pre graf-after--p">@attributeName</pre><pre name="477b" id="477b" class="graf graf--pre graf-after--pre">//Or with arguments‚Ä¶<br>@attributeName(arguments)</pre><p name="2629" id="2629" class="graf graf--p graf-after--pre">Let‚Äôs look at some examples from the front lines.</p><h4 name="5464" id="5464" class="graf graf--h4 graf-after--p">@available(args)</h4><p name="64a1" id="64a1" class="graf graf--p graf-after--h4">If there was a Swiss Army Knife version of a Swift attribute, it would be @available(). Flexible as it is powerful, you may find it indispensable if your daily duties revolve around managing or releasing an API. With it, one can indicate API naming changes, platform availability and more.</p><p name="d9de" id="d9de" class="graf graf--p graf-after--p">Consider an object from a metaphorical API that serves up blog posts:</p><pre name="b9b2" id="b9b2" class="graf graf--pre graf-after--p">class BasicPost {}</pre><p name="3325" id="3325" class="graf graf--p graf-after--pre">Consumers of our API have long enjoyed using the BasicPost class, though imagine we‚Äôve fielded several requests for a more honed in object that represents a technical blog post, much like the one you‚Äôre reading now. So for version 1.2, we introduce it:</p><pre name="a3aa" id="a3aa" class="graf graf--pre graf-after--p">class TechnicalPost {}</pre><p name="4f6a" id="4f6a" class="graf graf--p graf-after--pre">Now, to make our documentation complete, our code sensible and our API consumers informed we could take advantage of @available() to make its presence known:</p><pre name="55dd" id="55dd" class="graf graf--pre graf-after--p">@available(*, introduced: 1.2)<br>class TechnicalPost {}</pre><p name="7377" id="7377" class="graf graf--p graf-after--pre">Now, consumers can be quickly informed about the TechnicalPost object‚Äôs introduction and availability. This particular attribute can accept several arguments, but the first one always indicates the intended platforms. The remaining arguments supported can be supplied in any order.</p><p name="149b" id="149b" class="graf graf--p graf-after--p">It can also take advantage of a wildcard. In this case, the wildcard is the asterisk you‚Äôre seeing as the first argument‚Ää‚Äî‚Ääwhich communicates that on all platforms the API is used on, this class was first introduced on version 1.2 (represented by the second argument).</p><p name="8b68" id="8b68" class="graf graf--p graf-after--p">That‚Äôs neat, but also extremely broad. Thankfully, we can focus it in even more with a shorthand syntax:</p><pre name="d5e8" id="d5e8" class="graf graf--pre graf-after--p">@available(iOS 10.0, macOS 10.12)<br>class TechnicalPost {}</pre><p name="161f" id="161f" class="graf graf--p graf-after--pre">Much better! If I‚Äôm new to our fictional API, I can clearly see when this class can be used even if I don‚Äôt know much about the attribute itself.</p><p name="7d18" id="7d18" class="graf graf--p graf-after--p">But, if left as is, you‚Äôll also receive a compile time error. Why ü§î?</p><p name="8b90" id="8b90" class="graf graf--p graf-after--p">Because of Apple‚Äôs knack for introducing new platforms, we‚Äôve got to enforce our code to account for that‚Ää‚Äî‚Ääand so we include the wildcard as the last argument to signify that this code is available for the provided platforms, and any potential future platforms.</p><p name="6ca7" id="6ca7" class="graf graf--p graf-after--p">So if Apple makes the IoT connected Apple Toaster<strong class="markup--strong markup--p-strong">¬©</strong>‚Ää‚Äî‚Ääyou‚Äôre all set:</p><pre name="39a2" id="39a2" class="graf graf--pre graf-after--p">@available(iOS 10.0, macOS 10.12, *)<br>class TechnicalPost {}</pre><p name="be48" id="be48" class="graf graf--p graf-after--pre">Now our code is already set for the next big thing that needs a splash of Apple‚Äôs operating systems üéâ. For the here and the now though, Apple has provided us with an enumeration representing each platform as they exist today:</p><ul class="postList"><li name="a277" id="a277" class="graf graf--li graf-after--p"><code class="markup--code markup--li-code">iOS</code></li><li name="107d" id="107d" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">iOSApplicationExtension</code></li><li name="d9d1" id="d9d1" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">macOS</code></li><li name="0857" id="0857" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">macOSApplicationExtension</code></li><li name="8fe2" id="8fe2" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">watchOS</code></li><li name="ab30" id="ab30" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">watchOSApplicationExtension</code></li><li name="2a8a" id="2a8a" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">tvOS</code></li><li name="c174" id="c174" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">tvOSApplicationExtension</code></li></ul><p name="beec" id="beec" class="graf graf--p graf-after--li">Before we move on from this one let‚Äôs consider another commonality. With our recent changes, our API has taken off, and iOS developers the world over have entrusted us with serving them up with lovely bits of JSON that represent technical blog posts.</p><p name="1356" id="1356" class="graf graf--p graf-after--p">As such, we‚Äôve no need for the original class anymore. I think it‚Äôs time we deprecate it:</p><pre name="8e2c" id="8e2c" class="graf graf--pre graf-after--p">@available(*, deprecated: 1.3)<br>class BasicPost {}</pre><p name="5ba8" id="5ba8" class="graf graf--p graf-after--pre">Now it becomes clear how useful the wildcard argument can be, as in one (ahem) <em class="markup--em markup--p-em">swift</em> move we‚Äôve deprecated BasicPost on all platforms.</p><p name="76a4" id="76a4" class="graf graf--p graf-after--p">Further, if we wanted to keep it around but a bit refactored, we could‚Äôve even provided notice of an API naming change. Courtesy of a technique I caught from Apple, we could pair it with an unavailable argument and a typealias to make things even easier on consumers:</p><pre name="4fed" id="4fed" class="graf graf--pre graf-after--p">//From an earlier API version<br>class BasicPost {}</pre><pre name="0308" id="0308" class="graf graf--pre graf-after--pre">//From a new API version, where we renamed it for whatever reason<br>class BaseTechnicalPost {}</pre><pre name="9eb3" id="9eb3" class="graf graf--pre graf-after--pre">@available(*, unavailable, renamed: ‚ÄúBaseTechnicalPost‚Äù)<br>typealias BasicPost = BaseTechnicalPost</pre><p name="800c" id="800c" class="graf graf--p graf-after--pre">I personally love this, because for my money‚Ää‚Äî‚Ääthe obvious code is always the best code.</p><p name="682b" id="682b" class="graf graf--p graf-after--p">This attribute has even more tricks, with support for arguments specifying some code completely obsolete, a message to provide in conjunction with a warning or error and more.</p><h4 name="1da6" id="1da6" class="graf graf--h4 graf-after--p">@discardableResult</h4><p name="7337" id="7337" class="graf graf--p graf-after--h4">If you‚Äôve worked in a mature, legacy codebase it should come as no surprise that some functions do a bit too much.</p><p name="e3ed" id="e3ed" class="graf graf--p graf-after--p">Perhaps there is that one function hanging around that‚Äôs been added to and manipulated since the early 90s, and due to no fault of its own‚Ää‚Äî‚Ääit might do 124 important things that need to happen when the software starts (access a database, setup a cache, initialize some sign in process‚Ää‚Äî‚Ääthe scenarios are endless).</p><p name="d952" id="d952" class="graf graf--p graf-after--p">And so times go on, because someday, you‚Äôll convince the product manager to let you come back and refactor it.</p><p name="5689" id="5689" class="graf graf--p graf-after--p">Right üòÑ. <em class="markup--em markup--p-em">Right üòÖ!?</em> Right üòê:</p><pre name="8c95" id="8c95" class="graf graf--pre graf-after--p">let someUnusedVarBecauseIHaveToCallThisOldInsaneFunction = anOldInsaneFunction()</pre><p name="8200" id="8200" class="graf graf--p graf-after--pre">Be that as it may, clang will pour salt on the wound here because even though we‚Äôve got to invoke this function for some outlandish coupling reason‚Ää‚Äî‚Ääwe now have an unused variable to show for it as well. Talk about getting kicked while you‚Äôre down üôÉ.</p><p name="8e48" id="8e48" class="graf graf--p graf-after--p">This is where the @discardableResult attribute can help, as it tells the compiler that the result of the function may be unneeded. It also kills the warning at compile time:</p><pre name="6a1a" id="6a1a" class="graf graf--pre graf-after--p">@discardableResult func anOldInsaneFunction() -&gt; String<br>{<br>    //Bunch of business logic occurs<br>    return ‚Äú‚Äù<br>}</pre><p name="926b" id="926b" class="graf graf--p graf-after--pre">Now, the code above which invokes the said function will stay there only as a relic of your past software engineering mistakes‚Ää‚Äî‚Ääbut it will do so without providing an error. Baby steps!</p><p name="26af" id="26af" class="graf graf--p graf-after--p">For a little syntactical sugar, at least in my opinion, one could make the state of affairs even more obvious by simply assigning to a _¬†:</p><pre name="610e" id="610e" class="graf graf--pre graf-after--p">_ = anOldInsaneFunction()</pre><p name="00a4" id="00a4" class="graf graf--p graf-after--pre">Look‚Ää‚Äî‚Ääit is what it is. Sometimes, there are functions or architecture in software development we can‚Äôt directly control or fix, and this attribute makes that situation a little bit better.</p><h4 name="2fc3" id="2fc3" class="graf graf--h4 graf-after--p">@autoclosure</h4><p name="ea38" id="ea38" class="graf graf--p graf-after--h4">Let‚Äôs bring things home with another nifty attribute that can add a little syntactical sugar. The @autoclosure attribute can allow one to automatically wrap a closure that‚Äôs supplied as an argument. As the closure doesn‚Äôt take any arguments itself, it‚Äôll return the actual value of the expression that‚Äôs wrapped within it.</p><p name="f044" id="f044" class="graf graf--p graf-after--p">It sounds a little weird, but it‚Äôs easily understood when you come across one. All we‚Äôre really talking about here is the ability to get an expression to automatically become a closure. If you‚Äôve spent some time adding unit tests to your project, you‚Äôve likely come across this attribute several times already.</p><p name="c01d" id="c01d" class="graf graf--p graf-after--p">Assume we‚Äôd like to write a simple test for a class like so:</p><pre name="f4c9" id="f4c9" class="graf graf--pre graf-after--p">class Programmer<br>{<br>    var pay:Int<br>    <br>    init(withPay pay:Int)<br>    {<br>        self.pay = pay<br>    }</pre><pre name="d653" id="d653" class="graf graf--pre graf-after--pre">    func applyRaise(by amount:Int)<br>    {<br>        self.pay += amount<br>    }<br>}</pre><pre name="f9fc" id="f9fc" class="graf graf--pre graf-after--pre">class ProgrammerTests: XCTestCase<br>{<br>    func testPayRaise()<br>    {<br>        let devsPay = 50000<br>        let raiseAmount = 25000<br>        let expectedSalaryPostRaise = devsPay + raiseAmount</pre><pre name="974b" id="974b" class="graf graf--pre graf-after--pre">        let aDev = Programmer(withPay: devsPay)<br>        aDev.applyRaise(by: raiseAmount)</pre><pre name="d855" id="d855" class="graf graf--pre graf-after--pre">        XCTAssertEqual(expectedSalaryPostRaise, aDev.pay, &quot;Unexpected salary after raise was applied.&quot;)<br>     }<br>}</pre><p name="9e72" id="9e72" class="graf graf--p graf-after--pre">The first two parameters of the XCAssertEqual are both closures that take in a generic expression. While the function‚Äôs signature can look a little intimidating, take note of the first two parameters that are taking advantage of @autoclosure:</p><pre name="35e3" id="35e3" class="graf graf--pre graf-after--p">func XCTAssertEqual&lt;T&gt;(_ expression1: @autoclosure () throws -&gt; T?, _ expression2: @autoclosure () throws -&gt; T?, _ message: @autoclosure () -&gt; String = default, file: StaticString = #file, line: UInt = #line) where T : Equatable</pre><p name="f341" id="f341" class="graf graf--p graf-after--pre">Since the @autoclosure attribute is supplied, invoking the function is quite readable and trivial to write. We can either pass the closure with something as simple as a value (as we did in our previous example) or with a bit more logic, and each one is syntactically sensible:</p><pre name="558d" id="558d" class="graf graf--pre graf-after--p">class ProgrammerTests: XCTestCase<br>{<br>    func testPayRaise()<br>    {<br>        let devsPay = 50000<br>        let raiseAmount = 25000</pre><pre name="b2c9" id="b2c9" class="graf graf--pre graf-after--pre">        let aDev = Programmer(withPay: devsPay)<br>        aDev.applyRaise(by: raiseAmount)</pre><pre name="79d1" id="79d1" class="graf graf--pre graf-after--pre">        XCTAssertEqual(aDev.pay + raiseAmount, 750000, &quot;Unexpected salary after raise was applied.&quot;)<br>    }<br>}</pre><p name="b372" id="b372" class="graf graf--p graf-after--pre">Take note that when the first argument is supplied, it reads much more like an addition operation than it does a closure:</p><pre name="9548" id="9548" class="graf graf--pre graf-after--p">XCTAssertEqual(aDev.pay + raiseAmount, 750000, &quot;Unexpected salary after raise was applied.&quot;)</pre><p name="61c7" id="61c7" class="graf graf--p graf-after--pre">‚Ä¶versus what it might look like without the @autoclosure attribute:</p><pre name="9a95" id="9a95" class="graf graf--pre graf-after--p">XCTAssertEqual({<br>    return aDev.pay + raiseAmount,<br>}, {<br>    return 75000<br>}, &quot;Unexpected salary after raise was applied.&quot;)</pre><p name="b1fb" id="b1fb" class="graf graf--p graf-after--pre">As you can see, passing a fully qualified closure (in terms of syntax)‚Ää‚Äî‚Ääit‚Äôs a bit much to take in. Plus, that‚Äôs a compounded problem if one can‚Äôt use a trailing closure as the last argument.</p><p name="c92a" id="c92a" class="graf graf--p graf-after--p">So with @autoclosure, that‚Äôs essentially what we mean when we say that the closure <em class="markup--em markup--p-em">returns</em> <em class="markup--em markup--p-em">the actual value</em> that‚Äôs wrapped inside of it. You might even say the parameter became a closure‚Ä¶automatically, thus, @autoclosure üí°!</p><p name="d55d" id="d55d" class="graf graf--p graf-after--p">This code is also inherently delayed. This is an added benefit if the actual closure might end up being an expensive task or it might bring about some unintended side effects. The code provided is never executed until the closure it‚Äôs wrapped in is.</p><p name="8b1b" id="8b1b" class="graf graf--p graf-after--p">Another quick one‚Ää‚Äî‚Ääwhere else might you have seen this in your recent iOS endeavors? How about assert()?</p><pre name="a5f8" id="a5f8" class="graf graf--pre graf-after--p">struct Programmer<br>{<br>    var isSenior:Bool<br>    var appsShipped:Int<br>}</pre><pre name="05ea" id="05ea" class="graf graf--pre graf-after--pre">let aSeniorDev = Programmer(isSenior: true, appsShipped: 13)<br>assert(aSeniorDev.isSenior, ‚ÄúThis dev isn‚Äôt a senior!‚Äù)</pre><p name="8bb4" id="8bb4" class="graf graf--p graf-after--pre">The first argument provided uses @autoclosure. If it weren‚Äôt, again, the invocation might look something closer to this:</p><pre name="1897" id="1897" class="graf graf--pre graf-after--p">assert({ <br>    return aSeniorDev.isSenior <br>}, { <br>    return ‚ÄúThis dev isn‚Äôt a senior!‚Äù<br>})</pre><p name="8fa2" id="8fa2" class="graf graf--p graf-after--pre">With @autoclosure, the code is simply more digestible, and I would also argue that it also makes for a far more enjoyable reading experience.</p><p name="5cda" id="5cda" class="graf graf--p graf-after--p">And, if you‚Äôre curious how assert()‚Äôs signature looks, it‚Äôs something like this:</p><pre name="ab47" id="ab47" class="graf graf--pre graf-after--p">func assert(_ condition: @autoclosure () -&gt; Bool, _ message: @autoclosure () -&gt; String = default, file: StaticString = #file, line: UInt = #line)</pre><p name="7628" id="7628" class="graf graf--p graf-after--pre">If you‚Äôre thrown off by the other two parameters in the signature, we omitted them in the example because they have default values assigned to them. The more you know, right?</p><h4 name="d6d4" id="d6d4" class="graf graf--h4 graf-after--p">Before You Go‚Ää‚Äî‚ÄäUsing Multiple Attributes</h4><p name="0a77" id="0a77" class="graf graf--p graf-after--h4">While each attribute has benefits that help it stand on their own, it‚Äôs also helpful to pair them together in certain scenarios.</p><p name="bc5c" id="bc5c" class="graf graf--p graf-after--p">For example, take the @escaping attribute. The @escaping attribute signifies that the passed in closure can outlast the function it‚Äôs passed to:</p><pre name="351f" id="351f" class="graf graf--pre graf-after--p">//A property on a view controller<br>var onFakeCompletions:[()-&gt;()] = []</pre><pre name="0bf4" id="0bf4" class="graf graf--pre graf-after--pre">func fakeNetworkOp(_ completion:@escaping ()-&gt;())<br>{<br>    //Network stuff happens</pre><pre name="2093" id="2093" class="graf graf--pre graf-after--pre">    //The closure is appended to an external array outside of the   function&#39;s scope. This implies it could be invoked outside of the function - i.e., it could &quot;escape&quot; it<br>    onFakeCompletions.append(completion)<br>}</pre><p name="0210" id="0210" class="graf graf--p graf-after--pre">Considering this, we could use both @escaping <em class="markup--em markup--p-em">and</em> @autoclosure for the same parameter.</p><p name="7d09" id="7d09" class="graf graf--p graf-after--p">Let‚Äôs imagine H.R. let us know that any developer who is both a Senior in title and has shipped at least three apps is due for a raise, <em class="markup--em markup--p-em">but</em> we also need to keep track of each evaluation for historical purposes:</p><pre name="5d69" id="5d69" class="graf graf--pre graf-after--p">class Programmer<br>{<br>    var previousPayRaiseEvaluations:[()-&gt;Bool] = []<br>    var isSenior:Bool = false<br>    var appsShipped:Int = 0</pre><pre name="b35f" id="b35f" class="graf graf--pre graf-after--pre">    func evaluatePayRaise(withAccolades raiseEvaluation:@escaping @autoclosure ()-&gt;Bool)<br>    {<br>        if raiseEvaluation()<br>        {<br>            //Give them a raise, and then save it to their records<br>            previousPayRaiseEvaluations.append(raiseEvaluation)<br>        }<br>    }<br>}</pre><pre name="47ca" id="47ca" class="graf graf--pre graf-after--pre">let aProgrammer = Programmer()<br>aProgrammer.isSenior = true<br>aProgrammer.appsShipped = 4</pre><pre name="77e3" id="77e3" class="graf graf--pre graf-after--pre">print(&quot;Past pay raise evaluations: \(aProgrammer.previousPayRaiseEvaluations.count)&quot;) //0</pre><pre name="b9ed" id="b9ed" class="graf graf--pre graf-after--pre">aProgrammer.evaluatePayRaise(withAccolades: aProgrammer.isSenior &amp;&amp; aProgrammer.appsShipped &gt; 3)</pre><pre name="5dfc" id="5dfc" class="graf graf--pre graf-after--pre">print(&quot;Past pay raise evaluations: \(aProgrammer.previousPayRaiseEvaluations.count)&quot;) //1</pre><p name="14d5" id="14d5" class="graf graf--p graf-after--pre">And just like that üíØ!</p><p name="7b8f" id="7b8f" class="graf graf--p graf-after--p">There‚Äôs certainly nothing prohibiting you from ‚Äúchaining‚Äù attributes together, and when the situation calls for it, it works rather seamlessly.</p><h4 name="d224" id="d224" class="graf graf--h4 graf-after--p">Final Thoughts</h4><p name="e81c" id="e81c" class="graf graf--p graf-after--h4">Attributes have always been something I‚Äôve been particularly curious about. I like the idea of doing some heavy lifting in a clear, concise and simple way in my code‚Ää‚Äî‚Ääand that‚Äôs really what attributes are getting you.</p><p name="3d8b" id="3d8b" class="graf graf--p graf-after--p">Of course, there are the popular ones from the bunch worth knowing about, such as the ubiquitous @objc attribute in Swift + Objective-C projects. Certainly an argument could be made that attributes are almost more akin to a necessity rather than a nicety.</p><p name="7909" id="7909" class="graf graf--p graf-after--p">But, lest we forget, Swift does exist outside of iOS projects. And that‚Äôs an awesome thing, and my hope is that even though these attributes may not get the flashy headlines, perhaps they can help you when engineering your next bit of Swift code, iOS or otherwise.</p><p name="6b18" id="6b18" class="graf graf--p graf-after--p graf--trailing">Until next time‚Ää‚Äî‚Ääthanks for @reading ‚úåÔ∏è.</p></div></div></section><section name="0c57" class="section section--body section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><div name="e235" id="e235" class="graf graf--mixtapeEmbed graf--leading"><a href="https://www.twitter.com/jordanmorgan10" data-href="https://www.twitter.com/jordanmorgan10" class="markup--anchor markup--mixtapeEmbed-anchor" title="https://www.twitter.com/jordanmorgan10" rel="nofollow"><strong class="markup--strong markup--mixtapeEmbed-strong">Jordan Morgan (@JordanMorgan10) | Twitter</strong><br><em class="markup--em markup--mixtapeEmbed-em">The latest Tweets from Jordan Morgan (@JordanMorgan10). iOS at @buffer. Live to code so I created @dibsoftware‚Ä¶</em>www.twitter.com</a><a href="https://www.twitter.com/jordanmorgan10" class="js-mixtapeImage mixtapeImage u-ignoreBlock" data-media-id="4a77553981d2c05a97a19011f58601f6" data-thumbnail-img-id="0*DIFbFZFZUL4Tmv4_." style="background-image: url(https://cdn-images-1.medium.com/fit/c/160/160/0*DIFbFZFZUL4Tmv4_.);"></a></div><pre name="d6b8" id="d6b8" class="graf graf--pre graf-after--mixtapeEmbed graf--trailing">If you enjoyed this week&#39;s post, please feel free to go ahead and NSRecommend(this, where: below);</pre></div></div></section>
</section>
<footer><p>By <a href="https://medium.com/@JordanMorgan10" class="p-author h-card">Jordan Morgan</a> on <a href="https://medium.com/p/936f3426d5db"><time class="dt-published" datetime="2017-04-04T18:11:32.779Z">April 4, 2017</time></a>.</p><p><a href="https://medium.com/@JordanMorgan10/swift-attributes-936f3426d5db" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on October 23, 2018.</p></footer></article></body></html>